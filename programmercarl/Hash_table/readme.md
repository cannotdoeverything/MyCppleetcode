哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素
那么哈希表能解决什么问题呢，一般哈希表都是用来快速判断一个元素是否出现集合里。例如要查询一个名字是否在这所学校里。
要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到

哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。
哈希冲突，小李和小王都映射到了索引下标 1 的位置，这一现象叫做哈希冲突（哈希碰撞），一般哈希碰撞有两种解决方法， 拉链法和线性探测法
1.拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。
2.使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题


当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。

数组、set （集合）、map(映射)

集合	            底层实现	是否有序	数值是否可以重复	能否更改数值	查询效率	    增删效率
std::set	        红黑树	    有序	        否	            否	        O(logn)	    O(logn)
std::multiset	    红黑树	    有序	        是	            否	        O(logn)	    O(logn)
std::unordered_set	哈希表	    无序	        否	            否	        O(1)	    O(1)

红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。

映射	            底层实现	 是否有序	    数值是否可以重复	能否更改数值	查询效率	增删效率
std::map	        红黑树	    key有序	        key不可重复	    key不可修改	    O(logn)	    O(logn)
std::multimap	    红黑树	    key有序	        key可重复	    key不可修改	    O(logn)     O(logn)
std::unordered_map	哈希表	    key无序	        key不可重复	    key不可修改	      O(1)     	 O(1)

使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset

当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。

但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。
